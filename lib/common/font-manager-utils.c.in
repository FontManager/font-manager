/* font-manager-utils.c
 *
 * Copyright (C) 2009-2022 Jerry Casiano
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.
 *
 * If not, see <http://www.gnu.org/licenses/gpl-3.0.txt>.
*/

#include "font-manager-utils.h"

/**
 * SECTION: font-manager-utils
 * @title: Utility Functions
 * @short_description: General purpose utility functions
 * @include: font-manager-utils.h
 */

static const gchar *POSSIBLE_SCHEMA_DIRS[] = {
    "@prefix@/share/glib-2.0/schemas",
#ifdef NOT_REPRODUCIBLE
    "@abs_top_srcdir@/data"
#endif
};

static GSList *
get_possible_schema_dirs (void)
{
    GSList *slist = NULL;
    gchar *user_schema_dir = g_build_filename(g_get_user_data_dir(), "glib-2.0", "schemas", NULL);
    for (gint i = 0; i < (gint) G_N_ELEMENTS(POSSIBLE_SCHEMA_DIRS); i++)
        slist = g_slist_append(slist, g_strdup(POSSIBLE_SCHEMA_DIRS[i]));
    slist = g_slist_prepend(slist, user_schema_dir);
    slist = g_slist_append(slist, g_get_current_dir());
    return slist;
}

/**
 * font_manager_is_dir:
 * @filepath:   full path to file
 *
 * Returns:             %TRUE if @filepath is a directory
 */
gboolean
font_manager_is_dir (const gchar *filepath)
{
    return g_file_test(filepath, G_FILE_TEST_IS_DIR);
}

/**
 * font_manager_exists:
 * @filepath:   full path to file
 *
 * Returns:             %TRUE if @filepath exists
 */
gboolean
font_manager_exists (const gchar *filepath)
{
    return g_file_test(filepath, G_FILE_TEST_EXISTS);
}

static gboolean
ensure_dir_exists (const gchar *dir)
{
    return (G_LIKELY(font_manager_exists(dir)) || (g_mkdir_with_parents(dir, 0755) == 0));
}

/**
 * font_manager_natural_sort:
 * @str1:   a nul-terminated string
 * @str2:   a nul-terminated string
 *
 * Returns:             An integer less than, equal to, or greater than zero,
 *                      if str1 is <, == or > than str2 .
 */
gint
font_manager_natural_sort (const gchar *str1, const gchar *str2)
{
    g_return_val_if_fail((str1 != NULL && str2 != NULL), 0);
    g_autofree gchar *s1 = g_utf8_collate_key_for_filename(str1, -1);
    g_autofree gchar *s2 = g_utf8_collate_key_for_filename(str2, -1);
    return g_strcmp0(s1, s2);
}

/**
 * font_manager_get_file_owner:
 * @filepath:   full path to file
 *
 * Returns:     0 if current user has read/write permissions, -1 otherwise
 */
gint
font_manager_get_file_owner (const gchar *filepath)
{
    return g_access(filepath, R_OK | W_OK);
}

/**
 * font_manager_timecmp:
 * @a:  a valid filepath
 * @b:  a valid filepath
 *
 * Compare the modification time of two different files.
 *
 * Returns: An integer less than, equal to, or greater than zero, if a is <, == or > than b.
 */
gint
font_manager_timecmp (gchar *a, gchar *b)
{
    g_autoptr(GError) error = NULL;
    gchar *attrs = G_FILE_ATTRIBUTE_TIME_MODIFIED;
    GFileQueryInfoFlags flags = G_FILE_QUERY_INFO_NONE;
    g_autoptr(GFile) file_a = g_file_new_for_path(a);
    g_return_val_if_fail(g_file_query_exists(file_a, NULL), 0);
    g_autoptr(GFile) file_b = g_file_new_for_path(b);
    g_return_val_if_fail(g_file_query_exists(file_b, NULL), 0);
    g_autoptr(GFileInfo) info_a = g_file_query_info(file_a, attrs, flags, NULL, &error);
    g_return_val_if_fail(error == NULL, 0);
    g_autoptr(GFileInfo) info_b = g_file_query_info(file_b, attrs, flags, NULL, &error);
    g_return_val_if_fail(error == NULL, 0);
    g_autoptr(GDateTime) time_a = g_file_info_get_modification_date_time(info_a);
    g_return_val_if_fail(time_a != NULL, 0);
    g_autoptr(GDateTime) time_b = g_file_info_get_modification_date_time(info_b);
    g_return_val_if_fail(time_b != NULL, 0);
    return g_date_time_compare(time_a, time_b);
}

/**
 * font_manager_get_file_extension:
 * @filepath:   full path to file
 *
 * Returns: (transfer full) (nullable):
 * A newly allocated string that must be freed with #g_free or %NULL
 */
gchar *
font_manager_get_file_extension (const gchar *filepath)
{
    g_return_val_if_fail(filepath != NULL, NULL);
    g_return_val_if_fail(g_strrstr(filepath, ".") != NULL, NULL);
    gchar ** str_arr = g_strsplit(filepath, ".", -1);
    g_return_val_if_fail(str_arr != NULL, NULL);
    guint arr_len = g_strv_length(str_arr);
    g_autofree gchar *res = g_strdup(str_arr[arr_len - 1]);
    g_strfreev(str_arr);
    return g_ascii_strdown(res, -1);
}

/**
 * font_manager_get_local_time:
 *
 * Returns: (transfer full) (nullable): A newly allocated string formatted
 * to the requested format or %NULL if there was an error.
 * The returned string must be freed using #g_free().
 */
gchar *
font_manager_get_local_time (void)
{
    g_autoptr(GDateTime) local_time = g_date_time_new_now_local();
    return g_date_time_format(local_time, "%c");
}

/**
 * font_manager_get_user_font_directory:
 *
 * This function attempts to create the directory if it doesn't already exist
 * and returns the filepath as a string if successful.
 *
 * Returns: (transfer full) (nullable):
 * A newly allocated string that must be freed with #g_free or %NULL
 */
gchar *
font_manager_get_user_font_directory (void)
{
    g_autofree gchar *font_dir = g_build_filename(g_get_user_data_dir(), "fonts", NULL);
    if (ensure_dir_exists(font_dir))
        return g_steal_pointer(&font_dir);
    return NULL;
}

/**
 * font_manager_get_package_cache_directory:
 *
 * This function attempts to create the directory if it doesn't already exist
 * and returns the filepath as a string if successful.
 *
 * Returns: (transfer full) (nullable):
 * A newly allocated string that must be freed with #g_free or %NULL
 */
gchar *
font_manager_get_package_cache_directory (void)
{
    g_autofree gchar *cache_dir = g_build_filename(g_get_user_cache_dir(), "@PACKAGE_NAME@", NULL);
    if (ensure_dir_exists(cache_dir))
        return g_steal_pointer(&cache_dir);
    return NULL;
}

/**
 * font_manager_get_package_config_directory:
 *
 * This function attempts to create the directory if it doesn't already exist
 * and returns the filepath as a string if successful.
 *
 * Returns: (transfer full) (nullable):
 * A newly allocated string that must be freed with #g_free or %NULL
 */
gchar *
font_manager_get_package_config_directory (void)
{
    g_autofree gchar *config_dir = g_build_filename(g_get_user_config_dir(), "@PACKAGE_NAME@", NULL);
    if (ensure_dir_exists(config_dir))
        return g_steal_pointer(&config_dir);
    return NULL;
}

/**
 * font_manager_get_user_fontconfig_directory:
 *
 * This function attempts to create the directory if it doesn't already exist
 * and returns the filepath as a string if successful.
 *
 * Returns: (transfer full) (nullable):
 * A newly allocated string that must be freed with #g_free or %NULL
 */
gchar *
font_manager_get_user_fontconfig_directory (void)
{
    g_autofree gchar *config_dir = g_build_filename(g_get_user_config_dir(), "fontconfig", "conf.d", NULL);
    if (ensure_dir_exists(config_dir))
        return g_steal_pointer(&config_dir);
    return NULL;
}

/**
 * font_manager_str_replace: (skip)
 * @str:                a nul-terminated string
 * @target:             the nul-terminated string to search for
 * @replacement:        the nul-terminated string to replace target with
 *
 * Returns: (transfer full) (nullable):
 * A newly allocated string that must be freed with #g_free or %NULL
 */
gchar *
font_manager_str_replace (const gchar *str, const gchar *target, const gchar *replacement)
{
    g_return_val_if_fail((str != NULL && target != NULL && replacement != NULL), NULL);
    gchar *res = NULL;
    g_autoptr(GError) error = NULL;
    g_autofree gchar *escaped_str = g_regex_escape_string(target, -1);
    g_autoptr(GRegex) regex = g_regex_new(escaped_str, 0, 0, &error);
    if (error == NULL)
        res = g_regex_replace_literal(regex, str, -1, 0, replacement, 0, &error);
    if (error != NULL) {
        g_warning("%i - %s", error->code, error->message);
        g_clear_pointer(&res, g_free);
    }
    return res;
}

/**
 * font_manager_to_filename:
 * @str:                a nul-terminated string
 *
 * Replaces spaces and dashes with an underscore.
 *
 * Returns: (transfer full) (nullable):
 * A newly allocated string that must be freed with #g_free or %NULL
 */
gchar *
font_manager_to_filename (const gchar *str)
{
    g_return_val_if_fail(str != NULL, NULL);
    g_autofree gchar *tmp = font_manager_str_replace(str, " ", "_");
    return font_manager_str_replace(tmp, "-", "_");
}

/**
 * font_manager_install_file:
 * @file:       #GFile
 * @directory:  #GFile
 * @error:      #GError or %NULL to ignore errors
 *
 * Returns:     %TRUE if installation was successful.
 */
gboolean
font_manager_install_file (GFile *file, GFile *directory, GError **error)
{
    g_return_val_if_fail(error == NULL || *error == NULL, FALSE);
    g_return_val_if_fail(file != NULL, FALSE);
    g_return_val_if_fail(directory != NULL, FALSE);
    g_autoptr(GFile) target = font_manager_get_installation_target(file, directory, TRUE, error);
    g_return_val_if_fail(error == NULL || *error == NULL, FALSE);
    GFileCopyFlags flags = G_FILE_COPY_ALL_METADATA | G_FILE_COPY_OVERWRITE | G_FILE_COPY_TARGET_DEFAULT_PERMS;
    g_file_copy(file, target, flags, NULL, NULL, NULL, error);
    g_return_val_if_fail(error == NULL || *error == NULL, FALSE);
    return TRUE;
}

/**
 * font_manager_get_gsettings:
 * @schema_id:      the id of the schema
 *
 * Returns: (transfer full) (nullable):
 * A newly created #GSettings instance or %NULL if schema_id could not be found
 */
GSettings *
font_manager_get_gsettings (const gchar *schema_id)
{
    GSettingsSchemaSource *schema_source = g_settings_schema_source_get_default();
    g_return_val_if_fail(schema_source != NULL, NULL);
    g_autoptr(GSettingsSchema) schema = g_settings_schema_source_lookup(schema_source, schema_id, TRUE);
    if (schema != NULL) {
        g_debug("Using schema with id %s from default source", schema_id);
    } else {
        g_debug("No schema with id %s in default source", schema_id);
        g_debug("Checking fallback directories");
        GSList *slist = get_possible_schema_dirs();
        GSList *iter;
        for (iter = slist; iter != NULL; iter = iter->next) {
            const gchar *dir = iter->data;
            if (!g_file_test(dir, G_FILE_TEST_IS_DIR)) {
                g_debug("Skipping invalid or non-existent directory path %s", dir);
                continue;
            }
            g_autoptr(GSettingsSchemaSource) source = NULL;
            source = g_settings_schema_source_new_from_directory(dir, schema_source, FALSE, NULL);
            if (source == NULL) {
                g_debug("Failed to create schema source for %s", dir);
                continue;
            }
            g_debug("Checking for schema with id %s in %s", schema_id, dir);
            schema = g_settings_schema_source_lookup(source, schema_id, TRUE);
            if (schema != NULL) {
                g_debug("Using schema with id %s from %s", schema_id, dir);
                break;
            }
        }
        g_slist_free_full(slist, g_free);
        if (schema == NULL) {
            g_debug("Failed to locate schema for id %s", schema_id);
            g_debug("Settings will not persist");
            return NULL;
        }
    }
    return g_settings_new_full(schema, NULL, NULL);
}
